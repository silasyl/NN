<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
  </head>
  <body style="background-color:#FFFFFF;">
    <p>
      Draw a number digit and let the AI classify it.
    </p>
    <br />
    <br />
    <div>Output:</div>
    <canvas class="myCanvas">
      <p>Unfortunattely, your browser does not support canvas.</p>
    </canvas>
  </body>

<!-- Import TensorFlow.js library -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js" type="text/javascript">
</script> -->

<script type="module">
    
  // Screen variables
  const canvas = document.querySelector('.myCanvas');
  const width = canvas.width = 600;
  const height = canvas.height = 400;
  const ctx = canvas.getContext('2d');


  window.onload = function(){

    // IndexedDB
    if (!window.indexedDB){
      console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available");
    } else {

      // Create an instance of a db object for us to store our database in
      let db;


      // Define the fetchModelFromNetwork() function
      function fetchModelFromNetwork() {
        console.log('fetching model from network');
        // Fetch the model using the fetch() function, then expose their response bodies as blobs
        let modelBlob = fetch('/NN/model/model.json').then(response => response.blob());
        let binBlob = fetch('/NN/model/group1-shard1of1.bin').then(response => response.blob());

        // Only run the next code when both promises have fulfilled
        Promise.all([modelBlob, binBlob]).then(function(values) {
          // store it in the IDB using storeModel()
          storeModel(values[0], values[1]);
        });
      }


      // Define the storeModel() function
      function storeModel(modelBlob, binBlob) {
        // Open transaction, get object store; make it a readwrite so we can write to the IDB
        let objectStore = db.transaction(['model_os'], "readwrite").objectStore('model_os');
        // Create a structure to add to the IDB
        let structure = {
          model : modelBlob,
          bin : binBlob,
          name : "model"
        }

        // Add the structure to the IDB using add()
        let request = objectStore.add(structure);

        request.onsuccess = function() {
          console.log('Structure addition finished');
        }

        request.onerror = function() {
          console.log(request.error);
        }
      }


      /* Opening a database */
      // Open our database; it is created if it doesn't already exist
      // (see onupgradeneeded below)
      /*let req = indexedDB.deleteDatabase('model_db');
      req.onsuccess = function () {
          console.log("Deleted database successfully");
      };
      req.onerror = function () {
          console.log("Couldn't delete database");
      };
      req.onblocked = function () {
          console.log("Couldn't delete database due to the operation being blocked");
      };*/

      let request = window.indexedDB.open('model_db', 1);


      /* Generating handlers */
      // onerror handler signifies that the database didn't open successfully
      request.onerror = function() {
        console.log('Database failed to open');
      };

      // onsuccess handler signifies that the database opened successfully
      request.onsuccess = function(e) {
        console.log('Database opened succesfully');

        // Store the opened database object in the db variable. This is used a lot later
        db = e.target.result;
      };


      /* Creating or updating the version of the database */
      // Setup the database tables if this has not already been done
      request.onupgradeneeded = function(e) {
        
        // Save the IDBDatabase interface
        let db = e.target.result;

        // Create an objectStore for this database
        let objectStore = db.createObjectStore("model_os", { keyPath: 'name' });

        //// Define what data items the objectStore will contain
        //objectStore.createIndex('mp4', 'mp4', { unique: false });
        //objectStore.createIndex('webm', 'webm', { unique: false });

        // Use transaction oncomplete to make sure the objectStore creation is finished before adding data into it.
        // Open transaction, get object store, and get() the model
        objectStore.transaction.oncomplete = function(e) {
          // Store values in the newly created objectStore
          let customerObjectStore = db.transaction('model_os').objectStore('model_os');
          if (!customerObjectStore.result) {
            console.log('getting Model');
            fetchModelFromNetwork();
          }
        };


        console.log('Database setup complete');
      };
  }}


  async function load_model() {
    const model = await tf.loadLayersModel('indexeddb://model');
    return model;
  }


  const tf = require('@tensorflow/tfjs');
  const tfnode = require('@tensorflow/tfjs-node');

  async function loadModel() {
    const model = await tf.loadGraphModel("https://raw.githubusercontent.com/silasyl/NN/main/model/model.json");
    console.log("Model loaded:" + model);
  }


  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, width, height);

  const ROWS = 28;
  const COLS = 28;
  const OFFSET = 20;
  const CELL_SIZE = 10;
  let classification = null;

  let handwritting = Array(ROWS).fill().map(() => Array(COLS).fill(0));

  // Empty board
  for (let i = 0; i < ROWS; i++) {
    let row = [];
    for (let j = 0; j < COLS; j++) {
      ctx.fillStyle = 'white';
      ctx.fillRect(OFFSET+j*CELL_SIZE,OFFSET+i*CELL_SIZE,CELL_SIZE,CELL_SIZE);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeRect(OFFSET+j*CELL_SIZE,OFFSET+i*CELL_SIZE,CELL_SIZE,CELL_SIZE);
    }
  }

  // Reset button
  ctx.fillStyle = 'white';
  ctx.fillRect(30,OFFSET+ROWS*CELL_SIZE+30,100,30);
  ctx.fillStyle = 'black';
  ctx.font = '20px sans-serif';
  ctx.fillText('Reset', 50,OFFSET+ROWS*CELL_SIZE+52);

  // Classify button
  ctx.fillStyle = 'white';
  ctx.fillRect(160,OFFSET+ROWS*CELL_SIZE+30,100,30);
  ctx.fillStyle = 'black';
  ctx.font = '20px sans-serif';
  ctx.fillText('Classify', 170,OFFSET+ROWS*CELL_SIZE+52);

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // store mouse pointer coordinates
  let mousexy;
  let pressed = false;

  // update mouse pointer coordinates
  function getMousePos(canvas, evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };
  }

  // Check if button is clicked
   canvas.onmousedown = function() {
    pressed = true;
    if (mousexy.x >= 30 && mousexy.x <= 130 && mousexy.y >= OFFSET+ROWS*CELL_SIZE+30 && mousexy.y <= OFFSET+ROWS*CELL_SIZE+60) {
      // Reset drawing
      handwritting = Array(ROWS).fill().map(() => Array(COLS).fill(0));
      classification = null;
    }
    else if (mousexy.x >= 160 && mousexy.x <= 260 && mousexy.y >= OFFSET+ROWS*CELL_SIZE+30 && mousexy.y <= OFFSET+ROWS*CELL_SIZE+60) {
      // Generate classification
      //model = load_model();
      model = loadModel();
      console.log(model);
    }
  }

  canvas.onmouseup = function() {
    pressed = false;
  }

  canvas.onmousemove = function(evt) {
    mousexy = getMousePos(canvas, evt);
  }

  function draw() {
    if (pressed) {
      // Draw each grid cell
      for (let i = 0; i < ROWS; i++) {
        for (let j = 0; j < COLS; j++) {
          // If writing on this cell, fill in current cell and neighbors
          if (mousexy.x >= OFFSET+j*CELL_SIZE && mousexy.x < OFFSET+(j+1)*CELL_SIZE && mousexy.y >= OFFSET+i*CELL_SIZE && mousexy.y < OFFSET+(i+1)*CELL_SIZE) {
            handwritting[i][j] = 250/255;
            if (i+1 < ROWS) {
              handwritting[i+1][j] = 210/255;
            }
            if (j+1 < COLS) {
              handwritting[i][j+1] = 210/255;
            }
            if (i+1 < ROWS && j+1 < COLS) {
              handwritting[i+1][j+1] = 170/255;
            }
          }

          // If cell has been written on, darken cell
          if (handwritting[i][j]) {
            const channel = 255 - (handwritting[i][j] * 255);
            ctx.fillStyle = `rgb(${channel},${channel},${channel})`;
          }
          // Draw blank cell
          else {
            ctx.fillStyle = 'white';
          }
          ctx.fillRect(OFFSET+j*CELL_SIZE,OFFSET+i*CELL_SIZE,CELL_SIZE,CELL_SIZE);
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 1;
          ctx.strokeRect(OFFSET+j*CELL_SIZE,OFFSET+i*CELL_SIZE,CELL_SIZE,CELL_SIZE);
        }
      }
    }

    requestAnimationFrame(draw);
  }

  draw();







  </script>
</html>