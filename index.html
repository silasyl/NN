<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
  </head>
  <body style="background-color:#FFFFFF;">
    <p>
      Draw a number digit and let the AI classify it.
    </p>
    <br />
    <br />
    <div>Output:</div>
    <canvas class="myCanvas">
      <p>Unfortunattely, your browser does not support canvas.</p>
    </canvas>
  </body>

<!-- Import TensorFlow.js library -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js" type="text/javascript">
</script> -->

<script type="module">
    
  // Screen variables
  const canvas = document.querySelector('.myCanvas');
  const width = canvas.width = 600;
  const height = canvas.height = 400;
  const ctx = canvas.getContext('2d');
  
  (async () => {
    const model = await tf.loadLayersModel('localstorage://model');
    console.log(model);
    })();

  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, width, height);

  const ROWS = 28;
  const COLS = 28;
  const OFFSET = 20;
  const CELL_SIZE = 10;
  let classification = null;

  let handwritting = Array(ROWS).fill().map(() => Array(COLS).fill(0));

  // Empty board
  for (let i = 0; i < ROWS; i++) {
    let row = [];
    for (let j = 0; j < COLS; j++) {
      ctx.fillStyle = 'white';
      ctx.fillRect(OFFSET+j*CELL_SIZE,OFFSET+i*CELL_SIZE,CELL_SIZE,CELL_SIZE);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeRect(OFFSET+j*CELL_SIZE,OFFSET+i*CELL_SIZE,CELL_SIZE,CELL_SIZE);
    }
  }

  // Reset button
  ctx.fillStyle = 'white';
  ctx.fillRect(30,OFFSET+ROWS*CELL_SIZE+30,100,30);
  ctx.fillStyle = 'black';
  ctx.font = '20px sans-serif';
  ctx.fillText('Reset', 50,OFFSET+ROWS*CELL_SIZE+52);

  // Classify button
  ctx.fillStyle = 'white';
  ctx.fillRect(160,OFFSET+ROWS*CELL_SIZE+30,100,30);
  ctx.fillStyle = 'black';
  ctx.font = '20px sans-serif';
  ctx.fillText('Classify', 170,OFFSET+ROWS*CELL_SIZE+52);

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // store mouse pointer coordinates
  let mousexy;
  let pressed = false;

  // update mouse pointer coordinates
  function getMousePos(canvas, evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };
  }

  // Check if button is clicked
   canvas.onmousedown = function() {
    pressed = true;
    if (mousexy.x >= 30 && mousexy.x <= 130 && mousexy.y >= OFFSET+ROWS*CELL_SIZE+30 && mousexy.y <= OFFSET+ROWS*CELL_SIZE+60) {
      // Reset drawing
      handwritting = Array(ROWS).fill().map(() => Array(COLS).fill(0));
      classification = null;
    }
    else if (mousexy.x >= 160 && mousexy.x <= 260 && mousexy.y >= OFFSET+ROWS*CELL_SIZE+30 && mousexy.y <= OFFSET+ROWS*CELL_SIZE+60) {
      // Generate classification
      console.log(typeof handwritting);
    }
  }

  canvas.onmouseup = function() {
    pressed = false;
  }

  canvas.onmousemove = function(evt) {
    mousexy = getMousePos(canvas, evt);
  }

  function draw() {
    if (pressed) {
      // Draw each grid cell
      for (let i = 0; i < ROWS; i++) {
        for (let j = 0; j < COLS; j++) {
          // If writing on this cell, fill in current cell and neighbors
          if (mousexy.x >= OFFSET+j*CELL_SIZE && mousexy.x < OFFSET+(j+1)*CELL_SIZE && mousexy.y >= OFFSET+i*CELL_SIZE && mousexy.y < OFFSET+(i+1)*CELL_SIZE) {
            handwritting[i][j] = 250/255;
            if (i+1 < ROWS) {
              handwritting[i+1][j] = 210/255;
            }
            if (j+1 < COLS) {
              handwritting[i][j+1] = 210/255;
            }
            if (i+1 < ROWS && j+1 < COLS) {
              handwritting[i+1][j+1] = 170/255;
            }
          }

          // If cell has been written on, darken cell
          if (handwritting[i][j]) {
            const channel = 255 - (handwritting[i][j] * 255);
            ctx.fillStyle = `rgb(${channel},${channel},${channel})`;
          }
          // Draw blank cell
          else {
            ctx.fillStyle = 'white';
          }
          ctx.fillRect(OFFSET+j*CELL_SIZE,OFFSET+i*CELL_SIZE,CELL_SIZE,CELL_SIZE);
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 1;
          ctx.strokeRect(OFFSET+j*CELL_SIZE,OFFSET+i*CELL_SIZE,CELL_SIZE,CELL_SIZE);
        }
      }
    }

    requestAnimationFrame(draw);
  }

  draw();







  </script>
</html>